Graphs offer an effective way to capture meaningful relationships between data. Due to the growing size of our data, today there is tremendous interest in parallel algorithms for a variety of graph problems. One such graph problem is computing the PageRank of vertices in a graph, a measure that is based on each vertex's relative importance in the graph. It is a popular measure with applications such as ranking the websites \cite{page}, the scientific impact of researchers \cite{zomaya}, in the analysis of protein networks \cite{protein}, and in applications of neuroscience \cite{neuro}. It is therefore not surprising that there is recent interest in computing the PageRank values of vertices in a graph on shared memory architectures \cite{pr-sticd16,hipc17} and GPUs \cite{hipc19}. These approaches use a variety of solution approaches, viz., iterative, random walk, and matrix multiplication.

A limitation of the algorithms mentioned above for obtaining PageRank values on graphs is that the graph is static. However, networks from domains of applications to PageRank, such as protein networks, the web graph, collaboration networks, evolve with the insertion/deletion of edges/vertices. For the above algorithms to work on such evolving graphs, the only recourse is a full recomputation, which can be expensive given the large size of the graphs of interest.

A solution to this problem is to use dynamic graph algorithms that efficiently update a graph analytic upon the insertion/deletion of edges/vertices. Several authors have investigated dynamic algorithms for graph problems in the standard sequential computing model. These led to dynamic algorithms for fundamental problems on graphs such as connectivity, bi-connectivity, shortest paths, transitive closure, bipartite testing, and the like (see for instance \cite{eppstein}, and the references therein). On the other hand, parallel algorithms in this setting are relatively new. Some of the recent examples in the parallel setting include the work of Jamour et al. \cite{jamour}, Regunta et al. \cite{cent-shukla20}, and Mc Coll et al. \cite{cc-mccoll13}.

Many sequential dynamic graph algorithms follow the nomenclature of being incremental, decremental, or fully dynamic. An incremental algorithm can handle a {\em single} edge/vertex insertion (deletion for decremental). On the other hand, a fully dynamic algorithm can handle any single edge/vertex update (insertion or deletion). A parallel dynamic graph algorithm can, in addition, leverage parallelism owing to a batch of updates instead of a single edge/vertex update. Compared to a single update, a batch update also offers scope for reducing the overall work. We refer to such algorithms as {\em batch dynamic parallel graph algorithms}. 

Given the huge number of applications of PageRank, it is pertinent to design and engineer batch dynamic parallel algorithms that update the PageRank values of vertices without a full re-computation. In a recent work~\cite{hipc19} on this problem, Giri et al. propose the HyPR parallel algorithm which can update the ranks of an existing graph using a batch of edges on a heterogeneous computing platform consisting of a CPU and a GPU. The algorithm from \cite{hipc19} operates via updating the PageRank of all the affected vertices. However, identifying affected vertices from an inherently irregular graph leads to unbalanced parallel work which can be sub-optimal.

In this paper, we arrive at fully dynamic batch parallel algorithms for updating the PageRank values of vertices in a graph. Our algorithms work on both multicore CPUs and accelerators such as GPUs. Our algorithms identify affected vertices in sets of the strongly connected components (SCCs) of the underlying graph thereby improving on the work of \cite{hipc19}.




\subsection{Our Results}

Below is a summary of our results. We propose two dynamic parallel PageRank algorithms: \monolithicPR{} ({\bf Algorithm \ref{alg:monolithic}}), and \levelwisePR{} ({\bf Algorithm \ref{alg:levelwise}}). Both algorithms are based on the idea that they update the PageRank values of only the {\em affected} vertices in the SCCs of the graph under the insertion/deletion of a batch of edges.

We conduct detailed experimental studies on a collection of 11 real-world graphs (of four different classes) on an Intel multicore CPU, and an NVIDIA GPU. We observe the following:
\begin{itemize}
\item On the CPU, we observe a mean speedup of {4.2\X/5.8\X} for \monolithicPR{} and \levelwisePR{} respectively with respect to a pure CPU implementation of HyPR \cite{hipc19}, a state-of-the-art dynamic PageRank algorithm that only recomputes ranks of affected vertices in the graph. We observe a mean speedup of {6.1\X/8.6\X} with respect to the STIC-D algorithm \cite{pr-sticd16}, a static algorithm that recomputes the PageRank of all vertices in the graph. The above numbers the average of results obtained on batch sizes ranging from 500, 1000, 2000, 5000, and 10000 edges with an equal mix of insertions and deletions.
\item On the GPU, we observe a mean speedup of {1.9\X/1.8\X} for \monolithicPR{} and \levelwisePR{} respectively with respect to a pure GPU implementation of HyPR. We observe a mean speedup of {9.8\X/9.3\X} with respect to naive dynamic version of nvGraph PageRank \cite{pr-nvgraph}, a dynamic algorithm that computes the ranks of all vertices in the graph from the previous ranks of vertices. These observations are made on a similar set of batches.
\item In addition, we show that both our algorithms running on a batch of updates offer an advantage of {4066\X/2998\X} for \monolithicPR{} and \levelwisePR{} respectively on the CPU, and {1712\X/2324\X} on the GPU, over cumulative single-edge update version of the same algorithms on a batch size of 5000 edges with an equal mix of insertions and deletions.
\end{itemize}




\subsection{Related Work}

Techniques to improve the practical performance of algorithms for PageRank are a topic of recent research. Some of these, viz. \cite{pr-arasu02,pr-block03,pr-duong12} are directed only towards web graphs and may not translate to other real-world graphs. Broder et al. \cite{broder00} characterize the structure of web graphs as having a bow-tie nature with a large strongly connected component (SCC), and having a large number of incoming and outgoing edges. Arasu et al. \cite{pr-arasu02} use this characterization to represent PageRank as a solution to a set of independent matrix equations on a block upper triangular matrix. Kamvar et al. \cite{pr-block03} extend the characterization from Broder et al. \cite{broder00} to partition the input graph into blocks. Each block corresponds to a set of vertices in the same physical domain, and hence are naturally related. They compute a PageRank local to each block, called the {\em local} PageRank, and a PageRank for the blocks called as {\em BlockRank}. The final PageRank of vertices is a function of these two ranks. The final ranks thus computed by Kamvar et al. \cite{pr-block03} are approximate ranks and can differ from the PageRank values computed without using the block structure of the graph.

Other approximation based approaches include the work of SiteRank by Wu and Aberer \cite{wu}, the U-Model work of Broder et al. \cite{broder}, the ServerRank work of Wang et al. \cite{wang}, and the HostRank/DirRank work of Eiron et al. \cite{eiron}. Kohlschutter et al. \cite{kohlschutter} extend the results of Kamvar et al. \cite{pr-block03} to obtain exact PageRanks. 

One limitation of these works \cite{pr-block03,eiron,kohlschutter,wang,wu} is that their algorithms are tailored towards web graphs and may not work well for general-purpose graphs. As the PageRank measure finds applications in other domains, generic techniques find prominence. Garg et al. \cite{pr-sticd16} propose a multicore algorithm for obtaining PageRank values based on level-wise arrangement of the SCCs of the graph. This algorithm also introduces additional optimizations such as eliminating identical vertices, chain vertices, and vertices with converged ranks. Further improvements to this paper are reported by Panyala et al. \cite{hipc17}.

Parallel computation of PageRank on emerging architectures such as GPUs has been studied by Duong et al. \cite{pr-duong12}. The work does not introduce any algorithmic optimizations in the computation of PageRank. On the other hand, we believe that our algorithmic techniques will also apply to other architectures.

Expressing the PageRank computation as a Markov chain and solving for the steady-state transition probabilities of the underlying Markov chain is a mechanism used by many authors. Pandurangan et al. \cite{pr-sarma13} study such an approach in the distributed setting.

Importantly, all these consider only the static setting where the underlying graph does not change over time. Ramalingam \cite{incr-ramalingam96} argues for measuring the work done by a dynamic graph algorithm as a function of the change in the input and output, calling it as {\em bounded incremental computation}. The book presents bounded incremental algorithms in the sequential model for graph problems like shortest paths, circuit value annotation, and reducible flow graphs.  

Parallel dynamic graph algorithms on modern architectures are presented by Giri et al. \cite{hipc19} for PageRank, Regunta et al. \cite{cent-shukla20}, Haryan et al. \cite{cent-shukla20} for betweenness- and closeness-centrality, Bhowmick et al. \cite{sssp-khanda22} for shortest paths, and Bader et al. \cite{cc-mccoll13} for connectivity. The HyPR algorithm proposed by Giri et al.~\cite{hipc19} proposed a CPU+GPU hybrid implementation strategy for computing the PageRank scores on batches of heterogeneous updates. The batches contained a mix of both insert and delete operations and the data parallel operations were centered around the affected vertices in the graph. This may lead to limited utilization of the GPU since the number of affected vertices can vary widely depending upon the structure of the graph. The solution proposed in this paper is centered around the identification of the affected components of the graph rather than the vertices which leads to a extraction of higher amounts of parallelism at different levels of granularity.




% Monolithic Dynamic PageRank on an insert/delete batch of 5000 edges performs xx times faster than the nvGraph library implementation of a  static algorithm that recomputes the PageRank of all vertices in the graph. 
%Parallel algorithms often have to also contend with challenges from the architectural environment they are working on. It is common to encounter parallel algorithms that are efficient on one parallel architecture and inefficient on a different architecture. Hence, it is required that algorithm designers consider also the underlying architectural environment and arrive at algorithms that work well on a given architecture. In the present case too, we notice that our algorithm on multicore CPUs ({\bf cf.} Algorithm [monolithic] is not suitable for \emph{distributed CPU/GPUs}. We therefore have two separate algorithms: one for the GPU and one for the CPU. 


%\kk{REVISE *** Citations from ICDCN 2016 paper}


%\su{Sir we can also discuss about PageRank on large graphs, as in this paper "Scaling PageRank to 100 Billion Pages" where he discusses about the process of communicating ranks between partitions of the graph. With levelwise method we can avoid per-iteration communication (as long as each SCC fits on a PC).}
%\su{We could also discuss on the various variants of PageRank, like topic-sensitive PageRank.}
